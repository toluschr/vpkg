#!/bin/env python3

import multiprocessing
import subprocess
import threading
import itertools
import requests
import platform
import pathlib
import tomllib
import fnmatch
import lzma
import time
import zlib
import sys
import os
import re

import urllib.parse

from pydantic.dataclasses import dataclass
from pydantic import TypeAdapter

from datetime import datetime
from typing import Optional

from packaging.version import Version


@dataclass
class PackageSpec():
    url: Optional[str] = None
    name: Optional[str] = None
    not_deps: Optional[list[str]] = None
    version: Optional[str] = None
    last_modified: Optional[str | datetime] = None
    deps: Optional[list[str]] = None


@dataclass
class GithubSource():
    repository: str
    packages: Optional[dict[str, PackageSpec]] = None


@dataclass
class GithubAsset():
    name: str
    updated_at: str
    browser_download_url: str


@dataclass
class DebianSource():
    base_url: str
    distribution: str
    components: list[str]
    packages: Optional[dict[str, PackageSpec]] = None
    whitelist: Optional[list[str]] = None
    blacklist: Optional[list[str]] = None
    whitelist_autoappend: bool = False


@dataclass
class GithubRelease():
    assets: list[GithubAsset]


@dataclass
class Config():
    github_token: Optional[str] = None
    sources: Optional[dict[str, DebianSource | GithubSource | PackageSpec]] = None


@dataclass
class DebianPackage():
    package: str
    version: str
    depends: list[str]
    filename: str


def load_shlibs_mapping() -> dict[str, str]:
    with open("/var/lib/vpkg/shlibs", "r") as shlibs_file:
        shlibs_data = shlibs_file.read()

        out = dict()
        for line in shlibs_data.strip().split('\n'):
            if line.strip()[0] == '#':
                continue

            key, val = line.split(' ')[:2]
            out[key] = val

        return out


def rename_library(old_name: str) -> str:
    return re.sub(r"(lib.*)", r"\1-debian", old_name)


# This probably has a lot of bugs.
# https://www.debian.org/doc/debian-policy/ch-sharedlibs.html
def guess_shlibs_from_pkgname(pkgname: str) -> list[str]:
    if not pkgname.startswith("lib") or \
       pkgname.endswith("-cross") or \
       pkgname.endswith("-data")  or \
       pkgname.endswith("-java")  or \
       pkgname.endswith("-dev"):
        return []

    prefix = ""
    pkgver = ""

    out = []
    while True:
        # case: name
        if (match0 := re.search(r"[0-9.]+", pkgname)) is None:
            if not pkgver: pkgver = "0"
            out.append(f"{prefix}{pkgname}.so.{pkgver}")
            break

        span0 = match0.span()

        # case: name + number
        if len(pkgname) <= span0[1]:
            prefix += pkgname[:span0[0]].rstrip('-')
            out.append(f"{prefix}.so.{pkgname[span0[0]:span0[1]]}")
            break

        # case: name + number + multiple letters
        if (match1 := re.match("^[a-zA-Z+]{2,}", pkgname[span0[1]:])) is not None:
            span1 = match1.span()
            prefix += pkgname[:span0[1] + span1[1]]
            pkgname = pkgname[span0[1] + span1[1]:]
            continue

        # case: name + number + one letter
        if (match1 := re.match("^[a-zA-Z+]", pkgname[span0[1]:])) is not None:
            span1 = match1.span()
            out.append(f"{prefix}{pkgname[:span0[0]].rstrip('-')}.so.{pkgname[span0[0]:span0[1]]}")
            prefix = prefix + pkgname[:span0[1]]
            pkgname = pkgname[span0[1]:]
            pkgver = ""
            continue

        # case: name + number + dash + number
        if (match1 := re.match("^-[0-9.]+", pkgname[span0[1]:])) is not None:
            span1 = match1.span()
            prefix += pkgname[:span0[1] + span1[0]]
            pkgname = pkgname[span0[1] + span1[0] + 1:]
            continue

        # case: name + number + dash + name
        if (match1 := re.match("^-[a-zA-Z+]+", pkgname[span0[1]:])) is not None:
            span1 = match1.span()
            prefix += pkgname[:span0[0]]
            prefix += pkgver
            prefix += pkgname[span0[1] + span1[0]:span0[1] + span1[1]]
            pkgver = pkgname[span0[0]:span0[1]]
            pkgname = pkgname[span0[1] + span1[1]:]
            continue

    # https://stackoverflow.com/questions/69792413/replace-in-a-string-with-a-set-of-characters-give-all-possible-string-combi
    def do_iter(items):
        for s in items:
            for p in map(iter, itertools.product("_-", repeat=s.count('-'))):
                yield (''.join(c if c != '-' else next(p) for c in s))

    return list(do_iter(out))


# print(guess_shlibs_from_pkgname("liba52"))
# print(guess_shlibs_from_pkgname("libssh-gcrypt-4"))
# print(guess_shlibs_from_pkgname("librte-baseband-la12xx23")) # librte_baseband_la12xx.so.23
# print(guess_shlibs_from_pkgname("libkf5solid5"))
# print(guess_shlibs_from_pkgname("libkf5-5"))
# print(guess_shlibs_from_pkgname("liba52-0.7.4"))
# print(guess_shlibs_from_pkgname("libscrypt-kdf1"))
# print(guess_shlibs_from_pkgname("libcurl3-gnutls"))
# print(guess_shlibs_from_pkgname("libtinyxml2.6.2v5"))
# print(guess_shlibs_from_pkgname("libresid-builder0c2a"))
# print(guess_shlibs_from_pkgname("lib32go19-mips64r6"))
# print(guess_shlibs_from_pkgname("libsecp256k1-1"))
# print(guess_shlibs_from_pkgname("libglib3.5.8a5-asm5-3-5"))
# print(guess_shlibs_from_pkgname("libstxxl1v5"))
# print(guess_shlibs_from_pkgname("libmono-i18n4.0"))
# print(guess_shlibs_from_pkgname("libntfs-3g89"))
# print(guess_shlibs_from_pkgname("gir1.2-telepathyglib-0.12"))
# print(guess_shlibs_from_pkgname("libgir1.2-telepathyglib-0.12"))
# print(guess_shlibs_from_pkgname("libwayland-cursor++1"))
# exit()

def parse_debian_package(string: bytes | str) -> list[DebianPackage]:
    if isinstance(string, bytes):
        string = string.decode()

    assert isinstance(string, str)

    packages = list()
    for package_string in string.split("\n\n"):
        if len(package_string) == 0:
            continue

        package = dict()
        for entry_string in package_string.split("\n"):
            # skip continutations
            if entry_string[0].isspace():
                continue

            key, value = entry_string.split(": ", 1)
            package[key.lower()] = value

        if "depends" in package:
            package["depends"] = [re.sub(" .*", "", p) for p in re.split(", | \\| ", package["depends"])]
        else:
            package["depends"] = []

        packages.append(TypeAdapter(DebianPackage).validate_python(package))

    return packages


def print_package(p: PackageSpec):
    global print_lock

    with print_lock:
        if p.version is not None:
            print(f"[{p.name}-{p.version}]", file=vpkg_config_file)
        else:
            print(f"[{p.name}]", file=vpkg_config_file)

        if p.url is not None:
            print(f"url = {p.url}", file=vpkg_config_file)

        if p.deps is not None:
            print(f"deps = {' '.join(p.deps)}", file=vpkg_config_file)

        if p.not_deps is not None:
            print(f"not_deps = {' '.join(p.not_deps)}", file=vpkg_config_file)

        # if p.version is not None:
        #     print(f"version = {p.version}", file=vpkg_config_file)

        if p.last_modified is not None:
            assert isinstance(p.last_modified, datetime)

            last_modified_unix = int(time.mktime(p.last_modified.timetuple()))
            print(f"last_modified = {last_modified_unix}", file=vpkg_config_file)

        print("", file=vpkg_config_file)


def debian_version_to_xbps(version: str) -> str:
    return re.sub("[-/_]", '.', version)


def process_single_source(name, source):
    global machine, shlibs
    print(f"Syncing {name}", file=sys.stderr)

    if isinstance(source, DebianSource):
        parts = urllib.parse.urlparse(source.base_url)
        base_path = pathlib.Path(parts.path if parts.path else "/")
        distribution_path = base_path/source.distribution
        dists_path = distribution_path/"dists"
        binary_path = dists_path/'/'.join(source.components)/DEBIAN_BINARY

        try_fetch = [(binary_path/"Packages.xz", lambda d:
                      lzma.decompress(d)),
                     (binary_path/"Packages.gz", lambda d:
                      zlib.decompress(d, 16+zlib.MAX_WBITS)),
                     (binary_path/"Packages",
                      lambda d: d)]
        for path, function in try_fetch:
            package_url = urllib.parse.urlunparse((parts.scheme,
                                                   parts.netloc,
                                                   path.as_posix(),
                                                   "",
                                                   "",
                                                   ""))
            response = requests.get(package_url)

            if response.status_code == 200:
                content = function(response.content)
                break
        else:
            print(f"{name}: request failed", file=sys.stderr)
            return

        packages = parse_debian_package(content)

        for v in packages:
            if source.whitelist is not None and v.package not in source.whitelist:
                continue

            if source.blacklist is not None and v.package not in source.blacklist:
                continue

            manual_packages = source.packages if source.packages is not None else {}

            deb_path = distribution_path/v.filename
            deb_url = urllib.parse.urlunparse((parts.scheme,
                                               parts.netloc,
                                               deb_path.as_posix(),
                                               "",
                                               "",
                                               ""))

            p = manual_packages.setdefault(v.package, PackageSpec(name=None,
                                                                  not_deps=None,
                                                                  deps=None,
                                                                  url=None,
                                                                  last_modified=None,
                                                                  version=None))
            p.name = p.name if p.name is not None else rename_library(v.package)
            p.url = p.url if p.url is not None else deb_url
            p.version = p.version if p.version is not None else debian_version_to_xbps(v.version)
            # p.deps = p.deps if p.deps is not None else v.depends

            print_package(p)

            possible_shlibs = guess_shlibs_from_pkgname(v.package)
            with data_lock:
                for shlib in possible_shlibs:
                    shlibs.setdefault(shlib, f"{p.name}-{p.version}")

    elif isinstance(source, GithubSource):
        if source.packages is None:
            return

        path = pathlib.Path("/")/"repos"/source.repository/"releases"/"latest"
        url = urllib.parse.urlunparse(("https",
                                       "api.github.com",
                                       path.as_posix(),
                                       "",
                                       "",
                                       ""))

        response = requests.get(url)
        release = TypeAdapter(GithubRelease).validate_python(response.json())

        for k in source.packages.keys():
            for asset in release.assets:
                if fnmatch.fnmatch(asset.name, k):
                    p = source.packages[k]

                    t = datetime.strptime(asset.updated_at, '%Y-%m-%dT%H:%M:%SZ')
                    if p.name is None:
                        p.name = name

                    if p.url is None:
                        p.url = asset.browser_download_url

                    if p.last_modified is None:
                        p.last_modified = t

                    print_package(p)
                    break
            else:
                print(f"{source.repository}: No matches for package {k}", file=sys.stderr)

    elif isinstance(source, PackageSpec):
        if source.url is None:
            print(f"{name}: No URL, skipping.", file=sys.stderr)
            return

        response = requests.head(source.url, allow_redirects=True)
        t = datetime.strptime(response.headers["last-modified"],
                              "%a, %d %b %Y %H:%M:%S %Z")

        if source.name is None:
            source.name = name

        if source.last_modified is None:
            source.last_modified = t

        print_package(source)


def thread_fn(begin, length):
    assert config.sources is not None

    for name, source in list(config.sources.items())[begin:begin+length]:
        process_single_source(name, source)


machine = platform.machine()
match machine:
    case "i686": machine = "i386"
    case "x86_64": machine = "amd64"
    case "armv7l": machine = "armhf"
    case "aarch64": machine = "arm64"
    case _: raise ValueError(machine)

DEBIAN_BINARY = f"binary-{machine}"

# @todo: Don't output in critical section. Use queue.
print_lock = threading.Lock()
data_lock = threading.Lock()
vpkg_config_file = open("/etc/vpkg-install.ini", "w+")

if __name__ == '__main__':
    with open("/etc/vpkg-sync.toml", "rb") as config_file:
        p = tomllib.load(config_file)

    os.environ["XDEB_SHLIBS"] = "/var/lib/vpkg/shlibs"
    subprocess.run(["xdeb", "-SQ"])

    shlibs = load_shlibs_mapping()
    config = TypeAdapter(Config).validate_python(p)

    if config.sources is None:
        exit(0)

    try:
        numthreads = multiprocessing.cpu_count()
    except NotImplementedError:
        numthreads = 1

    numitems = len(config.sources)
    if numthreads > numitems:
        numthreads = numitems

    if numthreads == 1:
        for name, source in config.sources.items():
            process_single_source(name, source)
    else:
        threads = []
        for i in range(0, numthreads):
            size = (numitems + (numthreads - 1)) // numthreads
            threads.append(threading.Thread(target=thread_fn, args=(i*size, size)))
            threads[i].start()

        for i in range(0, numthreads):
            threads[i].join()

    with open("/var/lib/vpkg/shlibs", "w") as shlibs_file:
        shlibs_file.write('\n'.join([' '.join(item) for item in shlibs.items()]))

    vpkg_config_file.close()
