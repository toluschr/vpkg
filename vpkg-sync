#!/bin/env python3

import dataclasses
import datetime
import requests
import platform
import pathlib
import tomllib
import fnmatch
import dacite
import typing
import time
import zlib
import json
import sys

import urllib.parse

@dataclasses.dataclass
class PackageSpecification():
    url: typing.Optional[str]
    name: typing.Optional[str]
    not_deps: typing.Optional[list[str]]
    version: typing.Optional[str]
    last_modified: typing.Optional[str|datetime.datetime]
    deps: typing.Optional[list[str]]

@dataclasses.dataclass
class GithubAsset():
    name: str
    updated_at: str
    browser_download_url: str

@dataclasses.dataclass
class GithubSource(PackageSpecification):
    repository: str
    pattern: str

@dataclasses.dataclass
class DebianSource():
    base_url: str
    distribution: str
    components: list[str]
    packages: typing.Optional[dict[str, PackageSpecification]]
    whitelist: typing.Optional[list[str]]
    blacklist: typing.Optional[list[str]]

@dataclasses.dataclass
class GithubRelease():
    assets: list[GithubAsset]

@dataclasses.dataclass
class Config():
    github_token: typing.Optional[str]
    sources: typing.Optional[dict[str, DebianSource|GithubSource|PackageSpecification]]

machine = platform.machine()
match machine:
    case "x86_64": machine = "amd64"
    case _: raise ValueError(machine)

p = tomllib.load(open("vpkg-sync.toml", "rb"))

config = dacite.from_dict(data_class=Config, data=p)

def parse_debian_package(string: bytes | str):
    if isinstance(string, bytes):
        string = string.decode()

    assert isinstance(string, str)
    return [dict([em.split(": ", 1) for em in p.split("\n") if not em[0].isspace()]) for p in string.split("\n\n") if len(p) > 0]

def print_package(p: PackageSpecification):
    print(f"[{p.name}]")

    if p.url is not None:
        print(f"url = {p.url}")

    if p.deps is not None:
        print(f"deps = {' '.join(p.deps)}")

    if p.not_deps is not None:
        print(f"not_deps = {' '.join(p.not_deps)}")

    if p.version is not None:
        print(f"version = {p.version}")

    if p.last_modified is not None:
        assert isinstance(p.last_modified, datetime.datetime)
        print(f"last_modified = {int(time.mktime(p.last_modified.timetuple()))}")

    print()

for name, source in config.sources.items():
    if isinstance(source, DebianSource):
        parts = urllib.parse.urlparse(source.base_url)
        distribution_path = pathlib.Path(parts.path if parts.path else "/")/source.distribution
        package_path = distribution_path/"dists"/'/'.join(source.components)/f"binary-{machine}"/"Packages"

        package_url = urllib.parse.urlunparse((parts.scheme, parts.netloc, package_path.as_posix(), "", "", ""))
        response = requests.get(package_url)
        if response.status_code != 200:
            package_path = package_path.parent/"Packages.gz"
            package_url = urllib.parse.urlunparse((parts.scheme, parts.netloc, package_path.as_posix(), "", "", ""))

            response = requests.get(package_url)
            if response.status_code != 200:
                print(f"{name}: request failed", file=sys.stderr)

            content = zlib.decompress(response.content, 16+zlib.MAX_WBITS)
        else:
            content = response.content

        for item in parse_debian_package(content):
            k, v = item["Package"], item
            if source.whitelist is not None and k not in source.whitelist:
                continue

            if source.blacklist is not None and k in source.blacklist:
                continue

            packages = source.packages if source.packages is not None else {}

            binary_path = distribution_path/v["Filename"]
            binary_url = urllib.parse.urlunparse((parts.scheme, parts.netloc, binary_path.as_posix(), "", "", ""))

            p = packages.setdefault(k, PackageSpecification(name=None, not_deps=None, deps=None, url=None, last_modified=None, version=None))
            p.name = p.name if p.name is not None else k
            p.url = p.url if p.url is not None else binary_url
            p.version = p.version if p.version is not None else v["Version"]
            print_package(p)
    elif isinstance(source, GithubSource):
        path = pathlib.Path("/")/"repos"/source.repository/"releases"/"latest"
        url = urllib.parse.urlunparse(("https", "api.github.com", path.as_posix(), "", "", ""))

        response = requests.get(url)
        release = dacite.from_dict(data_class=GithubRelease, data=response.json())

        asset = None
        for asset_ in release.assets:
            if fnmatch.fnmatch(asset_.name, source.pattern):
                asset = asset_

        assert asset is not None

        t = datetime.datetime.strptime(asset.updated_at, '%Y-%m-%dT%H:%M:%SZ')

        source.name = source.name if source.name is not None else name
        source.url = source.url if source.url is not None else asset.browser_download_url
        source.last_modified = source.last_modified if source.last_modified is not None else t
        print_package(source)
    elif isinstance(source, PackageSpecification):
        response = requests.head(source.url, allow_redirects=True)
        t = datetime.datetime.strptime(response.headers["last-modified"], "%a, %d %b %Y %H:%M:%S %Z")

        source.name = source.name if source.name is not None else name
        source.last_modified = source.last_modified if source.last_modified is not None else t
        print_package(source)
